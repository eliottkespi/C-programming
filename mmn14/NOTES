registers x8 --> r0, r1, ... ,r8, PSW
each register is 15 bits
PSW ???

RAM:
size 4096
each cell is 15 bits -- cell = instruction

signed int & chars(ASCII) only
aritmetic is done with 2's complement

RAM is composed of sets of instructions (1 to 3 in a row)

New set of instruction start by A=1 R=0 E=0


----------------------------------------------------------------------------------------------------
Addressing modes:
Immediate:

A=1 R=0 E=0 <12 bits int>
usage: mov #-1,r0 -- move the value of -1 into register r0

Direct:

A=0 R=1 E=0 <12 bits int> -- internal file address
A=0 R=0 E=1 <12 bits int> -- external address
usage: if the following initialization was done -- x: .data 23
then: dec x -- will decrease 23 by 1.

Indirect:

A=1 R=0 E=0 <3 bits register> 0 0 0 0 0 <opcode> -- destination
A=1 R=0 E=0 0 0 0 <3 bits register> 0 0 <opcode> -- source
A=? R=? E=? <3 bits> <3 bits> -- but with different addressing modes ??? another instruction needs to be added
usage: 
inc *r1 -- increase by one the content of what r1 is pointing to
mov *r1, *r2 -- copy the content of what r1 is pointing to, into where r2 is pointing to

Direct register:

(looks like same than indirect addressing)
A=1 R=0 E=0 <3 bits register> 0 0 0 0 0 <opcode> -- destination
A=1 R=0 E=0 0 0 0 <3 bits register> 0 0 <opcode> -- source
usage: 
clr r1 -- zero the content of r1
mov r1, *r2 -- copy the content of r1 into the place where r2 is pointing to

----------------------------------------------------------------------------------------------------
OP codes:

2 operands:
0 - mov:
mov A, r1 -- copy the content of A (variable) to register 1

1 - cmp:
comparison of the 2 operands
how to: <destination> minus <source> operands -- if 0, then turn on Z flag in PSW register

2 - add:
add A, r1 -- r1 = r1+A

3 - sub:
sub #3 r1 -- r1 = r1-3

4 - lea:
???????

1 operand -- bits 7 8 9 10 will contain 0:
5 - clr:
clr r2 -- zero the content of r2

6 - not:
not r2 -- means make all the 0 to be 1 and the opposite in the content of r2

7 - inc:
inc r2 -- r2=r2+1

8 - dec:
dec C -- C=C-1

9 - jmp:
jmp LINE -- the pointer of the program called PC will jump to the line specified into the content of LINE variable and will continue from there

10 - bne:
bne LINE -- the pointer of the program called PC will jump the line specified into the content of LINE variable and will continue from there ONLY IF the Z flag in PSW register is 0

11 - red:
red r1 -- read 1 single character from STDIN and keep its ASCII value into r1

12 - prn:
prn r1 -- print to STDOUT the character corespinding to the ASCII code of the content if r1

13 - jsr;
jsr FUNC -- the pointer of the program called PC will be pushed into the program stack and the content of FUNC will replace it into PC
?????

no operand -- no need for operand so 3 4 5 6 7 8 9 10 will contain 0:
14 - rts:
rts -- back from subroutine, the PC value will be replaced by what is poped out of the program stack

15 - stop:
stop -- stop the program

----------------------------------------------------------------------------------------------------

Max length of line is 80 (\n not included)
; is comment

Max length of label/variable name is 31
label start with letter then letters/numbers
label/varible initialization is done <var>:
label is initialized only once
op name, instruction name or register name is not allowed to be used as label
label which includes .data or .string will be counted in the "data counter"
label which includes instruction will be counted in the "instruction counter"

numbers have to follow the folowing format: num , +num , -num | when num is integer
----------------------------------------------------------------------------------------------------
Directives:

directive dont includes ARE fields - so not instructions
directive use 15 bits
directive start with .<lower case>

.data:
.data 7,5,-9,33 -- tell the compiler to allocate in the "data image" the values of those parameters
XYZ: .data 7,5,-9,33 -- tell the compiler to allocate in the "data image" the values of those parameters and initialize XYZ to be the first one

mov XYZ, r1 -- will copy the value into XYZ - which is 7 - into r1
lea XYZ, r1 -- will copy into XYZ the address where 7 sits


.string:
STR: .string "abcde4" -- will save into STR the address which is pointing to the place in "data image" where the 7 words representing the ASCII value of a b c d e 4 \0 are keeped


.entry:

.entry HELLO 
HELLO: add #1, r1 -- make the variable HELLO available from other files 
HEY .entry HELLO -- make the variable HELLO available from other files but with a WARNING about unused HEY variable

.extern:
.extern HELLO -- import HELLO from other file
BLABLA .extern HELLO -- import HELLO from other file but with a WARNING about unused BLABLA variable

----------------------------------------------------------------------------------------------------
Tables:

opcode table:
contain corelation between opcode name and opcode binary code.
Will allow fast translation to binary code.

symbol table:
Built during first run.
Correlate between Symbol/Label name and his initialized value (in base 10)


----------------------------------------------------------------------------------------------------
Assemble:

First run:
Find labels (AKA Symbols) in the code, and correlate a number to each symbol.
This number will represent the symbol location in the memory.
Long story short: build the symbol table and translate (to binary code) every line which not contain a symbol


Second run:
We build the binary code of the lines which contains symbols.


----------------------------------------------------------------------------------------------------
Code structure:

<error>.h -- error messages
<main>.h
	Include DEBUG flag for debug compilation
<main>_tables.h
	opcode table configuration (and initialization ?)
	symbol table configuration (and initialization ?)
<main>_assembler.h
	data_image
	code_image
	IC
	DC

<main>logging.c -- general utilities 
	_WARNING -- print warning message to STDIN
	_ERROR -- print error to STDIN and exit 
	_DEBUG -- print message to STDIN
	_message -- print message to STDIN (used by _WARNING _DEBUG and _ERROR)

<main>_aritmetics.c
	add -- addition using 2's complement
	sub -- substraction using 2's complement
	two_s_complement -- 2's complement

<main>_assembler.c
	do_assembler -- start the assembler process on the given file
	do_first_run -- first run called by do_assembler
	do_second_run -- decond run called by do_assembler
	build_code -- build the binary code

<main>_io_utils.c
	this file will contain functions to parse and validate input and output

<main>.c
	Contain a for loop on every file from argument and do sned it to function do_assembler


----------------------------------------------------------------------------------------------------
Error handling:

Error ar going to stdout
Error need the specify what line number from which input file it is comming from.
If error is found, continue to pass over the input file (to raise more error if any) but dont create the ouput file.

possible errors:
unvalid operand number
unexisting operation
type of operand dont meet the operation
not existing register name
every label/symbol is initialized once only
invalid tpe of addressing based on the operation used (see table)
label extern AND initialized in the same program
----------------------------------------------------------------------------------------------------
2 arrays when each cell is a 15 bits "word" :
code_image - we keep in it the instructions translation to bin
data_image - we keep in it the data (directives .data and .string)

counters who point to the next free place in the according array - start a new input file will change the value to 0 :
IC - instructions counter
DC - data counter

symbol table includes:
symbol name, symbol value, code/data, entry/external

first run:
the assembler is reading line by line the input file
switch case on line type:
	empty line/comment - next line
	instruction line - 
		understand what is it about 
		if label/symbol included, new entry in symbol table with symbol value of IC+100 and code
		for every operand:
			operand == register --> operand = register 
			operand == label/symbol (means direct addressing)--> operand = symbol value
			operand start by # --> oprand = the number after the #
			operand == other --> use the according addressing value
		(reminder - if no specific operand, we mark them as 0)
		code_image[IC] = binary value of the first word of the line (includes opcode, addressing mode value)
		IC++
		if needed (based on adressing mode used) we "keep" the right amount of additional "word" in the code_image
	directive line -
		if .data
			if label included
				add new symbol to symbol table
				value = DC 
				data
			every number from the line is a new "word" in data_image
			DC += number of numbers we insterted
		if .string
			if label included
				add new symbol to symbol table
				value = DC 
				data
			the ASCII value of each char from the string is a new "word" in data_image
			we add \0 at the end (another "word")
			DC += strlen +1
		if .entry
			edit the given label/symbol in the symbol table to be entry
			(will be written into entries file output)
		if .extern
			add a the symbol to the symbol table 
				value = 0 (we dont care)
				external
in the symbol table:
	every data entry += IC+100

// now the symbol table is ready (except external value which are 0)

second run:
complete the binary code of the lines with symbol 

if no error found:
	build the binary code

----------------------------------------------------------------------------------------------------
Input & Output files

input files are given with args to the cmdline

for every input file, we have 3 output files:
	*.ob - include the binary code
	*.ext - info about all the symbols in symbol tables that are .extern
	*.ent - info about all the symbols in symbol tables that are .entry

input files have to be *.as type but when sending the filename as argument it is without the ".as"

output formats:
*.ob:
	HEADER: <number of "word" in the code_image> <number of "word" in the data_image>
	CONTENT: <"word" address in binary> <"word" content in octaly (XXXXX long)>
*.ent:
	CONTENT: <Symbol Name> <Symbol Value (decimal)>
*.ext:
	CONTENT: <Symbol Name> <Symbol Value (decimal)>






